nameOverride: ""
fullnameOverride: ""

image:
  repository: trinodb/trino
  tag: "403"
  pullPolicy: IfNotPresent
  pullSecrets: []

trino:
  node.properties:
    node.environment: kubernetes
    node.data-dir: /data/trino
    plugin.dir: /usr/lib/trino/plugin
  # Default values from: https://github.com/trinodb/trino/blob/master/core/docker/default/etc/jvm.config
  jvm.config: |
    -server
    -Xmx1G
    -XX:-UseBiasedLocking
    -XX:+UseG1GC
    -XX:G1HeapRegionSize=32M
    -XX:+ExplicitGCInvokesConcurrent
    -XX:+HeapDumpOnOutOfMemoryError
    -XX:+UseGCOverheadLimit
    -XX:+ExitOnOutOfMemoryError
    -XX:ReservedCodeCacheSize=256M
    -Djdk.attach.allowAttachSelf=true
    -Djdk.nio.maxCachedBufferSize=2000000
  log.properties:
    io.trino: INFO
  # https://trino.io/docs/current/admin/properties.html
  config.properties: {}
    # These properties are recommended to be tunned once the TASK-type fault-tolerant feature enabled
    # task.low-memory-killer.policy
    # query.low-memory-killer.delay
    # query.remote-task.max-error-duration
catalog: {}
  # memory.properties: |
  #   connector.name=memory
  # tpcds.properties: |
  #   connector.name=tpcds
  #   tpcds.splits-per-node=4

httpServer:
  http:
    enabled: true
    port: 8080
  https:
    enabled: false
    port: 8443
  keystore:
    path:
    key:
  truststore:
    path:
    key:

authen:
  enabled: false

  # Option: CUSTOM | KERBEROS | PASSWORD | OAUTH2
  type: CUSTOM
  sharedSecret:

  kerberos: {}
    # config: /etc/krb5.conf
    # keytab:
    ## ref: https://web.mit.edu/kerberos/krb5-1.12/doc/appdev/gssapi.html#name-types
    # nameType: # HOSTBASED_SERVICE (default) | USER_NAME
    # service-name:
    # principal-hostname:

  ## TODO: Support password authentication
  # password:
  #   # Option: file | ldap
  #   type: file

  #   ldap:
  #     # url:
  #     # user-base-dn:
  #     # user-bind-pattern:
  #     # group-auth-pattern:
  #     # cache-ttl:

  #     ## Trino server can use dedicated LDAP service user for doing user group membership queries.
  #     # bind-dn:
  #     # bind-password:

  #   file:
  #     # password-file:
  #     # refresh-period:
  #     # auth-token-cache.max-size:

  oauth2: {}
    # issuer:
    # auth-url:
    # jwks-url:
    # token-url:
    # client-id:
    # client-secret:
    # principal-field:
    # oidc.discovery: true

systemAccessControl:
  # Option: custom | allow-all | read-only | file
  name: allow-all

  file:
    refreshPeriod:
    rules:
      catalogs: []
      queries: []
      impersonation: []
    existingRulesPath:

commons:
  command: []
  args: []

  labels: {}
  podLabels: {}
  annotations: {}
  podAnnotations: {}

  resources: {}
  securityContext: {}
  podSecurityContext: {}

  schedulerName: null
  runtimeClassName: null
  priorityClassName: null

  affinity: {}
  tolerations: []
  nodeSelector: {}

  extraVolumeMounts: []
  extraVolumes: []

coordinator: {}
worker:
  replicas: null

cache:
  enabled: false

  persistence:
    enabled: false
    accessModes:
    - ReadWriteOnce
    storageClass: "-"
    size: 10Gi

faultTolerant:
  enabled: false
  # The retry-policy configuration. Allowed: QUERY or TASK
  policy: QUERY

  config: {}
    # exchange.deduplication-buffer-size:
    # exchange.compression-enabled:

    # QUERY:
    # query-retry-attempts:
    # retry-initial-delay:
    # retry-max-delay:
    # retry-delay-scale-factor:

    # TASK:
    # task-retry-attempts-overall:
    # task-retry-attempts-per-task:
    # retry-initial-delay:
    # retry-max-delay:
    # retry-delay-scale-factor:
    # fault-tolerant-execution-target-task-input-size:
    # fault-tolerant-execution-target-task-split-count:
    # fault-tolerant-execution-min-task-split-count:
    # fault-tolerant-execution-max-task-split-count:
    # fault-tolerant-execution-task-memory:
    # fault-tolerant-execution-task-descriptor-storage-max-memory:
    # fault-tolerant-execution-partition-count:
    # max-tasks-waiting-for-node-per-stage:

  exchangeManager:
    enable: false
    compress: false
    # s3, aws, azure, gcs, local

    config: {}

      # exchange-manager.name: filesystem

      # Tunning exchange-manager
      # exchange.sink-buffer-pool-min-size:
      # exchange.sink-buffers-per-partition:
      # exchange.sink-max-file-size:
      # exchange.source-concurrent-reader:

      # s3:
      # exchange.base-directories: s3://exchange-spooling-bucket/path/to/spool-dir
      # exchange.s3.region: my-region
      # exchange.s3.aws-access-key: access-key
      # exchange.s3.aws-secret-key: secret-key
      # exchange.s3.max-error-retries: 3
      # exchange.s3.path-style-access: true
      # exchange.s3.upload.part-size:

      # azure:
      # exchange.base-directories: abfs://container_name@account_name.dfs.core.windows.net
      # exchange.azure.connection-string: connection-string

      # gcs:
      # exchange.base-directories: gs://exchange-spooling-bucket/path/to/spool-dir
      # exchange.s3.region: my-region
      # exchange.s3.aws-access-key: access-key
      # exchange.s3.aws-secret-key: secret-key
      # exchange.s3.endpoint: https://storage.googleapis.com
      # exchange.gcs.json-key-file-path: /path/to/gcs_keyfile.json

      # local:
      # exchange.base-directories: /tmp/trino-exchange-manager

serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use.
  # If not set and create is true, a name is generated using the fullname template
  name:

metrics:
  enabled: false
  port: 9090
  podMonitor:
    enabled: false

service:
  type: ClusterIP
  httpPort: 8080
  httpsPort: 8443
  annotations: {}

ingress:
  enabled: false
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
    # nginx.ingress.kubernetes.io/ssl-passthrough: "true"
  hosts:
    - host: trino.local
      paths: []
  tls: []
  #  - secretName: trino.local-tls
  #    hosts:
  #      - trino.local
